<?xml version="1.0" encoding="UTF-8" ?>

<section xml:id="sec-binomial-distribution">
  <title>The binomial distribution</title>
  
  <p>
    As you might imagine, probability distributions vary enormously, and there's an enormous range of distributions out there. However, they aren't all equally important. In fact, the vast majority of the content in this book relies on one of five distributions: the binomial distribution, the normal distribution, the <m>t</m> distribution, the <m>\chi^2</m> ("chi-square") distribution and the <m>F</m> distribution. Given this, what I'll do over the next few sections is provide a brief introduction to all five of these, paying special attention to the binomial and the normal. I'll start with the binomial distribution, since it's the simplest of the five.
  </p>

  <subsection xml:id="subsec-introducing-binomial">
    <title>Introducing the binomial</title>
    
    <p>
      The theory of probability originated in the attempt to describe how games of chance work, so it seems fitting that our discussion of the <term>binomial distribution</term> should involve a discussion of rolling dice and flipping coins. Let's imagine a simple "experiment": in my hot little hand I'm holding 20 identical six-sided dice. On one face of each die there's a picture of a skull; the other five faces are all blank. If I proceed to roll all 20 dice, what's the probability that I'll get exactly 4 skulls? Assuming that the dice are fair, we know that the chance of any one die coming up skulls is 1 in 6; to say this another way, the skull probability for a single die is approximately <m>.167</m>. This is enough information to answer our question, so let's have a look at how it's done.
    </p>

    <p>
      As usual, we'll want to introduce some names and some notation. We'll let <m>N</m> denote the number of dice rolls in our experiment; which is often referred to as the <term>size parameter</term> of our binomial distribution. We'll also use <m>\theta</m> to refer to the the probability that a single die comes up skulls, a quantity that is usually called the <term>success probability</term> of the binomial. Finally, we'll use <m>X</m> to refer to the results of our experiment, namely the number of skulls I get when I roll the dice. Since the actual value of <m>X</m> is due to chance, we refer to it as a <term>random variable</term>. In any case, now that we have all this terminology and notation, we can use it to state the problem a little more precisely. The quantity that we want to calculate is the probability that <m>X = 4</m> given that we know that <m>\theta = .167</m> and <m>N=20</m>. The general "form" of the thing I'm interested in calculating could be written as
    </p>

    <me>P(X \ | \ \theta, N)</me>

    <p>
      and we're interested in the special case where <m>X=4</m>, <m>\theta = .167</m> and <m>N=20</m>. There's only one more piece of notation I want to refer to before moving on to discuss the solution to the problem. If I want to say that <m>X</m> is generated randomly from a binomial distribution with parameters <m>\theta</m> and <m>N</m>, the notation I would use is as follows:
    </p>

    <me>X \sim \mbox{Binomial}(\theta, N)</me>

    <p>
      Yeah, yeah. I know what you're thinking: notation, notation, notation. Really, who cares? Very few readers of this book are here for the notation, so I should probably move on and talk about how to use the binomial distribution. To that end, Figure <xref ref="fig-4binomial1"/> plots the binomial probabilities for all possible values of <m>X</m> for our dice rolling experiment, from <m>X=0</m> (no skulls) all the way up to <m>X=20</m> (all skulls). Note that this is basically a bar chart, and is no different to the "pants probability" plot I drew in <xref ref="fig-4pantsprob"/>. On the horizontal axis we have all the possible events, and on the vertical axis we can read off the probability of each of those events. So, the probability of rolling 4 skulls out of 20 times is about 0.20 (the actual answer is 0.2022036, as we'll see in a moment). In other words, you'd expect that to happen about 20% of the times you repeated this experiment.
    </p>

    <remark>
      <title>R Code</title>
      <program language="r">
        <input>
knitr::include_graphics("imgs/navarro_img/probability/binomSkulls20-eps-converted-to.png")
        </input>
      </program>
    </remark>

    <figure xml:id="fig-4binomial1">
      <caption>The binomial distribution with size parameter of N =20 and an underlying success probability of 1/6. Each vertical bar depicts the probability of one specific outcome (i.e., one possible value of X). Because this is a probability distribution, each of the probabilities must be a number between 0 and 1, and the heights of the bars must sum to 1 as well.</caption>
      <image source="images/navarro_img/probability/binomSkulls20-eps-converted-to.png"/>
    </figure>
  </subsection>

  <subsection xml:id="subsec-binomial-in-r">
    <title>Working with the binomial distribution in R</title>
    
    <p>
      R has a function called <c>dbinom</c> that calculates binomial probabilities for us. The main arguments to the function are
    </p>

    <ul>
      <li><p><c>x</c> This is a number, or vector of numbers, specifying the outcomes whose probability you're trying to calculate.</p></li>
      <li><p><c>size</c> This is a number telling R the size of the experiment.</p></li>
      <li><p><c>prob</c> This is the success probability for any one trial in the experiment.</p></li>
    </ul>

    <p>
      So, in order to calculate the probability of getting skulls, from an experiment of trials, in which the probability of getting a skull on any one trial is ... well, the command I would use is simply this:
    </p>

    <remark>
      <title>R Code</title>
      <program language="r">
        <input>
dbinom( x = 4, size = 20, prob = 1/6 )
        </input>
      </program>
    </remark>

    <program language="r">
      <input>
dbinom( x = 4, size = 20, prob = 1/6 )
      </input>
      <output>
[1] 0.2022036
      </output>
    </program>

    <p>
      To give you a feel for how the binomial distribution changes when we alter the values of <m>\theta</m> and <m>N</m>, let's suppose that instead of rolling dice, I'm actually flipping coins. This time around, my experiment involves flipping a fair coin repeatedly, and the outcome that I'm interested in is the number of heads that I observe. In this scenario, the success probability is now <m>\theta = 1/2</m>. Suppose I were to flip the coin <m>N=20</m> times. In this example, I've changed the success probability, but kept the size of the experiment the same. What does this do to our binomial distribution?
    </p>

    <remark>
      <title>R Code</title>
      <program language="r">
        <input>
knitr::include_graphics("imgs/navarro_img/probability/Binomial2.png")
        </input>
      </program>
    </remark>

    <figure xml:id="fig-4binomial2">
      <caption>Two binomial distributions, involving a scenario in which I'm flipping a fair coin, so the underlying success probability is 1/2. In panel (a), we assume I'm flipping the coin N = 20 times. In panel (b) we assume that the coin is flipped N = 100 times.</caption>
      <image source="images/navarro_img/probability/Binomial2.png"/>
    </figure>

    <p>
      Well, as <xref ref="fig-4binomial2"/> <m>a</m> shows, the main effect of this is to shift the whole distribution, as you'd expect. Okay, what if we flipped a coin <m>N=100</m> times? Well, in that case, we get <xref ref="fig-4binomial2"/> <m>b</m>. The distribution stays roughly in the middle, but there's a bit more variability in the possible outcomes.
    </p>

    <p>
      At this point, I should probably explain the name of the <c>dbinom</c> function. Obviously, the "binom" part comes from the fact that we're working with the binomial distribution, but the "d" prefix is probably a bit of a mystery. In this section I'll give a partial explanation: specifically, I'll explain why there is a prefix. As for why it's a "d" specifically, you'll have to wait until the next section. What's going on here is that R actually provides <em>four</em> functions in relation to the binomial distribution. These four functions are <c>dbinom</c>, <c>pbinom</c>, <c>rbinom</c> and <c>qbinom</c>, and each one calculates a different quantity of interest. Not only that, R does the same thing for <em>every</em> probability distribution that it implements. No matter what distribution you're talking about, there's a <c>d</c> function, a <c>p</c> function, <c>r</c> a function and a <c>q</c> function.
    </p>

    <p>
      Let's have a look at what all four functions do. Firstly, all four versions of the function require you to specify the <c>size</c> and <c>prob</c> arguments: no matter what you're trying to get R to calculate, it needs to know what the parameters are. However, they differ in terms of what the other argument is, and what the output is. So let's look at them one at a time.
    </p>

    <ul>
      <li><p>The <c>d</c> form we've already seen: you specify a particular outcome <c>x</c>, and the output is the probability of obtaining exactly that outcome. (the "d" is short for <em>density</em>, but ignore that for now).</p></li>
      <li><p>The <c>p</c> form calculates the <term>cumulative probability</term>. You specify a particular quantile <c>q</c> , and it tells you the probability of obtaining an outcome <em>smaller than or equal to</em> <c>q</c>.</p></li>
      <li><p>The <c>q</c> form calculates the <term>quantiles</term> of the distribution. You specify a probability value <c>p</c>, and it gives you the corresponding percentile. That is, the value of the variable for which there's a probability <c>p</c> of obtaining an outcome lower than that value.</p></li>
      <li><p>The <c>r</c> form is a <term>random number generator</term>: specifically, it generates <c>n</c> random outcomes from the distribution.</p></li>
    </ul>

    <p>
      This is a little abstract, so let's look at some concrete examples. Again, we've already covered <c>dbinom</c> so let's focus on the other three versions. We'll start with <c>pbinom</c>, and we'll go back to the skull-dice example. Again, I'm rolling 20 dice, and each die has a 1 in 6 chance of coming up skulls. Suppose, however, that I want to know the probability of rolling 4 <em>or fewer</em> skulls. If I wanted to, I could use the <c>dbinom</c> function to calculate the exact probability of rolling 0 skulls, 1 skull, 2 skulls, 3 skulls and 4 skulls and then add these up, but there's a faster way. Instead, I can calculate this using the <c>pbinom</c> function. Here's the command:
    </p>

    <remark>
      <title>R Code</title>
      <program language="r">
        <input>
pbinom( q= 4, size = 20, prob = 1/6)
        </input>
      </program>
    </remark>

    <program language="r">
      <input>
pbinom( q= 4, size = 20, prob = 1/6)
      </input>
      <output>
[1] 0.7687492
      </output>
    </program>

    <p>
      In other words, there is a 76.9% chance that I will roll 4 or fewer skulls. Or, to put it another way, R is telling us that a value of 4 is actually the 76.9th percentile of this binomial distribution.
    </p>

    <p>
      Next, let's consider the <c>qbinom</c> function. Let's say I want to calculate the 75th percentile of the binomial distribution. If we're sticking with our skulls example, I would use the following command to do this:
    </p>

    <remark>
      <title>R Code</title>
      <program language="r">
        <input>
qbinom( p = 0.75, size = 20, prob = 1/6 )
        </input>
      </program>
    </remark>

    <program language="r">
      <input>
qbinom( p = 0.75, size = 20, prob = 1/6 )
      </input>
      <output>
[1] 4
      </output>
    </program>

    <p>
      Hm. There's something odd going on here. Let's think this through. What the <c>qbinom</c> function appears to be telling us is that the 75th percentile of the binomial distribution is 4, even though we saw from the function that 4 is <em>actually</em> the 76.9th percentile. And it's definitely the <c>pbinom</c> function that is correct. I promise. The weirdness here comes from the fact that our binomial distribution doesn't really <em>have</em> a 75th percentile. Not really. Why not? Well, there's a 56.7% chance of rolling 3 or fewer skulls (you can type <c>pbinom(3, 20, 1/6)</c> to confirm this if you want), and a 76.9% chance of rolling 4 or fewer skulls. So there's a sense in which the 75th percentile should lie "in between" 3 and 4 skulls. But that makes no sense at all! You can't roll 20 dice and get 3.9 of them come up skulls. This issue can be handled in different ways: you could report an in between value (or <term>interpolated</term> value, to use the technical name) like 3.9, you could round down (to 3) or you could round up (to 4).
    </p>

    <p>
      The <c>qbinom</c> function rounds upwards: if you ask for a percentile that doesn't actually exist (like the 75th in this example), R finds the smallest value for which the the percentile rank is <em>at least</em> what you asked for. In this case, since the "true" 75th percentile (whatever that would mean) lies somewhere between 3 and 4 skulls, R Rounds up and gives you an answer of 4. This subtlety is tedious, I admit, but thankfully it's only an issue for discrete distributions like the binomial. The other distributions that I'll talk about (normal, <m>t</m>, <m>\chi^2</m> and <m>F</m>) are all continuous, and so R can always return an exact quantile whenever you ask for it.
    </p>

    <p>
      Finally, we have the random number generator. To use the <c>rbinom</c> function, you specify how many times R should "simulate" the experiment using the <c>n</c> argument, and it will generate random outcomes from the binomial distribution. So, for instance, suppose I were to repeat my die rolling experiment 100 times. I could get R to simulate the results of these experiments by using the following command:
    </p>

    <remark>
      <title>R Code</title>
      <program language="r">
        <input>
rbinom( n = 100, size = 20, prob = 1/6 )
        </input>
      </program>
    </remark>

    <program language="r">
      <input>
rbinom( n = 100, size = 20, prob = 1/6 )
      </input>
      <output>
[1]  2  2  1  4  3  4  1  4  4  2  6  4  3  4  4  2  4  0  4  3  4  3  1  6  5
[26] 3  4  2  3  2  3  4  3  2  3  2  4  2  3  1  3  5  4  2  1  2  1  4  3  3
[51] 3  1  6  4  2  5  4  2  1  1  2  3  2  4  2  2  2  4  4  5  1  5  3  3  3
[76] 2  3  2  1  3  3  0  4  3  5  5  4  1  3  3  2  2  4  5  4  2  2  6  3  2
      </output>
    </program>

    <p>
      As you can see, these numbers are pretty much what you'd expect given the distribution shown in <xref ref="fig-4binomial1"/>. Most of the time I roll somewhere between 1 to 5 skulls. There are a lot of subtleties associated with random number generation using a computer, but for the purposes of this book we don't need to worry too much about them.
    </p>
  </subsection>

</section>
